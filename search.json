[{"path":"https://eppicenter.github.io/dcifer/articles/vignetteDcifer.html","id":"read-and-reformat-data-estimate-coi-and-population-allele-frequencies","dir":"Articles","previous_headings":"","what":"Read and reformat data, estimate COI and population allele frequencies","title":"Dcifer: Genetic Distance Between Polyclonal Infections","text":"Dcifer relatedness estimation requires sample data specific format well estimates complexity infection (COI) population allele frequencies. example preparation steps using Mozambique dataset. First, read original data stored .csv file long format. name file first argument function reads reformats data: , reformat R data frame (dlong) containing dataset: Next, estimate COI samples - use naive estimation, first ranking loci sample number detected alleles, using locus prescribed rank (lrank) determine COI: Finally, estimate population allele frequencies, adjusting COI: situations, population allele frequencies might estimated different (e.g. larger) dataset provided separately (e.g. .csv file R data frame): case, frequencies read , need checked existing data object make sure loci alleles order. Function matchAfreq performs checking rearranges sample data conform provided allele frequencies. procedure, loci alleles lists (dsmp afreq) named; otherwise names required, order loci alleles assumed sample data allele frequencies. afreq contains “extra” alleles listed dsmp, alleles added dsmp. opposite situation (alleles listed present dsmp listed afreq) result error.","code":"sfile <- system.file(\"extdata\", \"MozParagon.csv\", package = \"dcifer\") dsmp <- readDat(sfile, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\") str(dsmp, list.len = 2) > List of 52 >  $ 8025874217:List of 87 >   ..$ t1  : Named num [1:5] 1 1 0 0 0 >   .. ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... >   ..$ t10 : Named num [1:4] 1 0 0 0 >   .. ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" >   .. [list output truncated] >  $ 8025874237:List of 87 >   ..$ t1  : Named num [1:5] 0 0 0 0 1 >   .. ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... >   ..$ t10 : Named num [1:4] 1 0 0 0 >   .. ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" >   .. [list output truncated] >   [list output truncated] dsmp <- formatDat(dlong, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\") # optionally, extract location information meta <- unique(read.csv(sfile)[c(\"sampleID\", \"province\")]) meta <- meta[match(names(dsmp), meta$sampleID), ]  # order samples as in dsmp lrank <- 2 coi   <- getCOI(dsmp, lrank = lrank) afreq <- calcAfreq(dsmp, coi, tol = 1e-5)  str(afreq, list.len = 2) > List of 87 >  $ t1  : Named num [1:5] 0.4239 0.2808 0.1116 0.0422 0.1415 >   ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... >  $ t10 : Named num [1:4] 0.8539 0.00942 0.00951 0.12717 >   ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" >   [list output truncated] afile  <- system.file(\"extdata\", \"MozAfreq.csv\", package = \"dcifer\") afreq2 <- readAfreq(afile, lvar = \"locus\", avar = \"allele\", fvar = \"freq\") # alternatively, if allele frequencies are provided in an R data frame (aflong): afreq2 <- formatAfreq(aflong, lvar = \"locus\", avar = \"allele\", fvar = \"freq\") dsmp2  <- matchAfreq(dsmp, afreq2)"},{"path":"https://eppicenter.github.io/dcifer/articles/vignetteDcifer.html","id":"estimate-relatedness","dir":"Articles","previous_headings":"","what":"Estimate relatedness","title":"Dcifer: Genetic Distance Between Polyclonal Infections","text":"first step relatedness estimation, set \\(M = 1\\) (one pair strains two infections can related) test hypothesis infections unrelated (\\(H_0\\!: r = 0\\)). done ibdDat function. explore significantly related pairs detail. Optionally, sort samples clinic geographic location: Look results single pair samples:","code":"provinces <- c(\"Maputo\", \"Inhambane\") nsite     <- table(meta$province)[provinces] ord       <- order(factor(meta$province, levels = provinces)) dsmp <- dsmp[ord] coi  <- coi[ ord] dres <- ibdDat(dsmp, coi, afreq, pval = TRUE, confint = TRUE, rnull = 0,                 alpha = 0.05, nr = 1e3) dres[9, 5, ] >   estimate    p_value   CI_lower   CI_upper  > 0.31100000 0.06203213 0.00000000 0.68000000"},{"path":"https://eppicenter.github.io/dcifer/articles/vignetteDcifer.html","id":"visualize-the-results","dir":"Articles","previous_headings":"","what":"Visualize the results","title":"Dcifer: Genetic Distance Between Polyclonal Infections","text":"pairwise relatedness calculated within single dataset, ibdDat returns triangular matrices. plotting, can make symmetric. significantly related pairs can outlined either triangles. Display results sample ID’s written margins. Label colors correspond locations (health facilities):  symmetric distance measures, one triangles can used display relevant information, p-values, geographic distance, number non-missing loci two samples. , use add = TRUE.  reference, add colorbar legend plot. can placed beside main plot:  colorbar can also located empty space left triangular matrix. example , specify horizontal colorbar provide custom tick mark locations:","code":"par(mar = c(3, 3, 1, 1)) nsmp  <- length(dsmp) atsep <- cumsum(nsite)[-length(nsite)]  # create symmetric matrix dmat <- dres[, , \"estimate\"] dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))]   # determine significant, indices for upper triangle alpha <- 0.05                          # significance level                     isig <- which(dres[, , \"p_value\"] <= alpha, arr.ind = TRUE) col_id <- rep(c(\"plum4\", \"lightblue4\"), nsite) plotRel(dmat, isig = isig[, 2:1], draw_diag = TRUE, alpha = alpha, idlab = TRUE,         col_id = col_id) abline(v = atsep, h = atsep, col = \"gray45\", lty = 5) par(mfrow = c(1, 2), mar = c(1, 0, 1, 0.2)) plotRel(dres, draw_diag = TRUE, alpha = alpha) mtext(\"p-values\", 3, 0.2) # p-values for upper triangle pmat <- matrix(NA, length(dsmp), length(dsmp)) pmat[upper.tri(pmat)] <- t(log(dres[, , \"p_value\"]))[upper.tri(pmat)] pmat[pmat == -Inf] <- min(pmat[is.finite(pmat)])#*1.2 plotRel(pmat, rlim = NULL, draw_diag = TRUE, col = hcl.colors(101, \"Red-Purple\"),          sig = FALSE, add = TRUE, col_diag = \"white\", border_diag = \"gray45\") abline(v = atsep, h = atsep, col = \"gray45\", lty = 5)  # number of non-missing loci for upper triangle dmiss <- lapply(dsmp, function(lst) sapply(lst, function(v) all(!v))) nmat <- matrix(NA, nsmp, nsmp)  for (jsmp in 2:nsmp) {   for (ismp in 1:(jsmp - 1)) {     nmat[ismp, jsmp] <- sum(!dmiss[[ismp]] & !dmiss[[jsmp]])   } } nrng <- range(nmat, na.rm = TRUE)  #   par(mar = c(1, 0.2, 1, 0)) plotRel(dres, draw_diag = TRUE, alpha = alpha) mtext(\"number of loci\", 3, 0.2) coln <- hcl.colors(diff(nrng)*2.4, \"Purple-Blue\", rev = TRUE)[1:(diff(nrng) + 1)] plotRel(nmat, rlim = NA, col = coln, add = TRUE,          draw_diag = TRUE, col_diag = \"gray45\", border_diag = \"white\") par(pardef) layout(matrix(1:2, 1), width = c(7, 1)) par(mar = c(1, 1, 2, 1))#, mgp = c(0, 0, 0.5)) plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1])) atclin <- cumsum(nsite) - nsite/2 abline(v = atsep, h = atsep, col = \"gray45\", lty = 5) mtext(provinces, side = 3, at = atclin, line = 0.2) mtext(provinces, side = 2, at = atclin, line = 0.2) par(mar = c(1, 0, 2, 3)) plotColorbar() par(pardef) # horizontal colorbar (needed?) par(mar = c(1, 1, 1, 3)) border_sig = \"darkviolet\" plotRel(dres, draw_diag = TRUE, border_diag = border_sig, alpha = alpha,          border_sig = border_sig, lwd_sig = 2) legend(32, 20, pch = 0, col = border_sig, pt.lwd = 2, pt.cex = 1.4,         box.col = \"gray\", legend = expression(\"significant at\" ~~ alpha == 0.05)) text(1:nsmp + 0.3, 1:nsmp - 0.5, labels = names(dsmp), col = col_id, adj = 0,      cex = 0.6, xpd = TRUE) par(fig = c(0.25, 1, 0.81, 0.92), mar = c(1, 1, 1, 1), new = TRUE) plotColorbar(at = c(0.2, 0.4, 0.6, 0.8), horiz = TRUE) ncol <- 301 lines(c(0, ncol, ncol, 0, 0), c(0, 0, 1, 1, 0), col = \"gray\") par(pardef)"},{"path":"https://eppicenter.github.io/dcifer/articles/vignetteDcifer.html","id":"further-analysis-of-related-samples","dir":"Articles","previous_headings":"","what":"Further analysis of related samples","title":"Dcifer: Genetic Distance Between Polyclonal Infections","text":"Examine pairs determined significantly related significance level \\(\\alpha\\) closely allowing multiple pairs strains related two infections. Using ibdEstM, also estimate number positively related pairs \\(M'\\) strains compare results yielded constrained model assuming \\(r_1 = \\dotso = r_M\\) (faster method) without constraint. addition, look estimates \\(\\hat{r}_{total}\\) overall relatedness. Create list significant pairs: full control, can use function ibdPair two samples explore outputs: llik = TRUE, output includes log-likelihood (single parameter use equalr = TRUE), provides basis statistical inference:","code":"# First, create a grid of r values to evaluate over revals <- mapply(generateReval, 1:5, nr = c(1e3, 1e2, 32, 16, 12)) sig1 <- sig2 <- vector(\"list\", nrow(isig)) for (i in 1:nrow(isig)) {   sig1[[i]] <- ibdEstM(dsmp[isig[i, ]], coi[isig[i, ]], afreq, Mmax = 5,                         equalr = FALSE, reval = revals) } for (i in 1:nrow(isig)) {   sig2[[i]] <- ibdEstM(dsmp[isig[i, ]], coi[isig[i, ]], afreq, equalr = TRUE) } M1      <- sapply(sig1, function(r) sum(r > 0))   M2      <- sapply(sig2, length)           rtotal1 <- sapply(sig1, sum)     rtotal2 <- sapply(sig2, sum)      cor(M1, M2) > [1] 0.9486851 cor(rtotal1, rtotal2) > [1] 0.9998965 samples <- names(dsmp) sig <- as.data.frame(isig, row.names = FALSE) sig[c(\"id1\", \"id2\")]         <- list(samples[isig[, 1]], samples[isig[, 2]]) sig[c(\"M1\", \"M2\")]           <- list(M1, M2) sig[c(\"rtotal1\", \"rtotal2\")] <- list(round(rtotal1, 3), round(rtotal2, 3)) head(sig) >   row col        id1        id2 M1 M2 rtotal1 rtotal2 > 1  14   2 8025874706 8025874271  1  1   0.410   0.412 > 2  52   2 8034209790 8025874271  1  1   0.133   0.133 > 3  25   3 8034209803 8025874316  1  1   1.000   1.000 > 4  16   5 8025874872 8025874340  2  2   0.520   0.516 > 5  17   6 8025874928 8025874357  1  1   1.000   1.000 > 6  21   6 8025875042 8025874357  1  1   0.881   0.881 i <- 18                               pair <- dsmp[isig[i, ]] coii <-  coi[isig[i, ]]  res1 <- ibdPair(pair, coii, afreq, M = M1[i], pval = TRUE, equalr = FALSE,                   reval = revals[[M1[i]]]) res2 <- ibdPair(pair, coii, afreq, M = M2[i], pval = TRUE, equalr = TRUE,                   confreg = TRUE, llik = TRUE, reval = revals[[1]])  res1$rhat                              # estimate with equalr = FALSE > [1] 0.31 1.00 rep(res2$rhat, M2[i])                  # estimate with equalr = TRUE > [1] 0.673 0.673 CI     <- range(res2$confreg) llikCI <- max(res2$llik) - qchisq(1 - alpha, df = 1)/2 llrng  <- range(res2$llik[is.finite(res2$llik)]) yCI <- llrng + diff(llrng)*0.25 yLR <- (res2$llik[1] + max(res2$llik))/2 cols <- c(\"purple\", \"cadetblue3\", \"gray60\")  par(mar = c(3, 2.5, 2, 0.1), mgp = c(1.5, 0.3, 0)) plot(revals[[1]], res2$llik, type = \"l\", xlab = \"r\", ylab = \"log-likelihood\",       yaxt = \"n\")#, tck = -0.01) abline(v = res2$rhat, lty = 1, col = cols[1]) abline(h = c(max(res2$llik), llikCI, res2$llik[[1]]), lty = 2, col = cols[2]) abline(v = CI, col = cols[1], lty = 5) arrows(CI[1], yCI, CI[2], yCI, angle = 20, length = 0.1, code = 3,         col = cols[3]) arrows(0.15, res2$llik[1], 0.15, max(res2$llik), angle = 20, length = 0.1,         code = 3, col = cols[3]) text(0.165, yLR, adj = 0, \"0.5 LR statistic\", col = cols[3]) text(mean(CI), yCI + 0.05*diff(llrng), \"confidence interval\", col = cols[3]) text(res2$rhat - 0.025, yLR, \"MLE\", col = cols[3], srt = 90) par(pardef)"},{"path":"https://eppicenter.github.io/dcifer/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Inna Gerlovina. Author, maintainer.","code":""},{"path":"https://eppicenter.github.io/dcifer/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gerlovina (2022). dcifer: Genetic Relatedness Polyclonal Infections. https://github.com/EPPIcenter/dcifer, https://eppicenter.github.io/dcifer/.","code":"@Manual{,   title = {dcifer: Genetic Relatedness Between Polyclonal Infections},   author = {Inna Gerlovina},   year = {2022},   note = {https://github.com/EPPIcenter/dcifer, https://eppicenter.github.io/dcifer/}, }"},{"path":"https://eppicenter.github.io/dcifer/index.html","id":"dcifer-genetic-distance-between-polyclonal-infections","dir":"","previous_headings":"","what":"Genetic Relatedness Between Polyclonal Infections","title":"Genetic Relatedness Between Polyclonal Infections","text":"Package dcifer (Distance Complex Infections: Fast Estimation Relatedness) calculates genetic distance polyclonal infections estimating relatedness biallelic multiallelic data [1]. addition estimates, package provides likelihood function statistical inference. Functions reading reformatting data, performing preparatory steps, visualizing results also included. illustrate analysis process using microhaplotype data two health facilities Maputo Inhambane provinces Mozambique [2]. can install released version dcifer CRAN : development version GitHub :","code":"install.packages(\"dcifer\") # install.packages(\"remotes\") remotes::install_github(\"EPPIcenter/dcifer\") # or, to include a vignette: remotes::install_github(\"EPPIcenter/dcifer\", build_vignettes = TRUE) library(dcifer) help(package = \"dcifer\") vignette(package = \"dcifer\", \"vignetteDcifer\") pardef <- par(no.readonly = TRUE)"},{"path":"https://eppicenter.github.io/dcifer/index.html","id":"read-and-reformat-data-estimate-coi-and-population-allele-frequencies","dir":"","previous_headings":"","what":"Read and reformat data, estimate COI and population allele frequencies","title":"Genetic Relatedness Between Polyclonal Infections","text":"Dcifer relatedness estimation requires sample data specific format well estimates complexity infection (COI) population allele frequencies. example preparation steps using Mozambique dataset. First, read original data stored .csv file long format. name file first argument function reads reformats data: , reformat R data frame (dlong) containing dataset: Next, estimate COI samples - use naive estimation, first ranking loci sample number detected alleles, using locus prescribed rank (lrank) determine COI: Finally, estimate population allele frequencies, adjusting COI: situations, population allele frequencies might estimated different (e.g. larger) dataset provided separately (e.g. .csv file R data frame): case, frequencies read , need checked existing data object make sure loci alleles order. Function matchAfreq performs checking rearranges sample data conform provided allele frequencies. procedure, loci alleles lists (dsmp afreq) named; otherwise names required, order loci alleles assumed sample data allele frequencies. afreq contains “extra” alleles listed dsmp, alleles added dsmp. opposite situation (alleles listed present dsmp listed afreq) result error.","code":"sfile <- system.file(\"extdata\", \"MozParagon.csv\", package = \"dcifer\") dsmp <- readDat(sfile, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\") str(dsmp, list.len = 2) #> List of 52 #>  $ 8025874217:List of 87 #>   ..$ t1  : Named num [1:5] 1 1 0 0 0 #>   .. ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... #>   ..$ t10 : Named num [1:4] 1 0 0 0 #>   .. ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" #>   .. [list output truncated] #>  $ 8025874237:List of 87 #>   ..$ t1  : Named num [1:5] 0 0 0 0 1 #>   .. ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... #>   ..$ t10 : Named num [1:4] 1 0 0 0 #>   .. ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" #>   .. [list output truncated] #>   [list output truncated] dsmp <- formatDat(dlong, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\") # optionally, extract location information meta <- unique(read.csv(sfile)[c(\"sampleID\", \"province\")]) meta <- meta[match(names(dsmp), meta$sampleID), ]  # order samples as in dsmp lrank <- 2 coi   <- getCOI(dsmp, lrank = lrank) afreq <- calcAfreq(dsmp, coi, tol = 1e-5)  str(afreq, list.len = 2) #> List of 87 #>  $ t1  : Named num [1:5] 0.4239 0.2808 0.1116 0.0422 0.1415 #>   ..- attr(*, \"names\")= chr [1:5] \"D10--D6--FCR3--V1-S.0\" \"HB3.0\" \"t1.0\" \"t1.1\" ... #>  $ t10 : Named num [1:4] 0.8539 0.00942 0.00951 0.12717 #>   ..- attr(*, \"names\")= chr [1:4] \"D10--D6--HB3.0\" \"t10.0\" \"t10.2\" \"U659.0\" #>   [list output truncated] afile  <- system.file(\"extdata\", \"MozAfreq.csv\", package = \"dcifer\") afreq2 <- readAfreq(afile, lvar = \"locus\", avar = \"allele\", fvar = \"freq\") # alternatively, if allele frequencies are provided in an R data frame (aflong): afreq2 <- formatAfreq(aflong, lvar = \"locus\", avar = \"allele\", fvar = \"freq\") dsmp2  <- matchAfreq(dsmp, afreq2)"},{"path":"https://eppicenter.github.io/dcifer/index.html","id":"estimate-relatedness","dir":"","previous_headings":"","what":"Estimate relatedness","title":"Genetic Relatedness Between Polyclonal Infections","text":"first step relatedness estimation, set  (one pair strains two infections can related) test hypothesis infections unrelated (). done ibdDat function. explore significantly related pairs detail. purposes demonstration, first estimate relatedness display results using dsmp created previously samples sorted location. Look results single pair samples: Alternatively, may want first sort samples clinic geographic location:","code":"dres0 <- ibdDat(dsmp, coi, afreq, pval = TRUE, confint = TRUE, rnull = 0,                  alpha = 0.05, nr = 1e3) dres0[17, 10, ]   #>   estimate    p_value   CI_lower   CI_upper  #> 0.31100000 0.06203212 0.00000000 0.68000000 provinces <- c(\"Maputo\", \"Inhambane\") nsite     <- table(meta$province)[provinces] ord       <- order(factor(meta$province, levels = provinces)) dsmp <- dsmp[ord] coi  <- coi[ ord] dres <- ibdDat(dsmp,  coi, afreq, nr = 1e3)"},{"path":"https://eppicenter.github.io/dcifer/index.html","id":"visualize-the-results","dir":"","previous_headings":"","what":"Visualize the results","title":"Genetic Relatedness Between Polyclonal Infections","text":"pairwise relatedness calculated within single dataset, ibdDat returns triangular matrices. plotting, can make symmetric. significantly related pairs can outlined either triangles. Display results unsorted samples, sample ID’s written margins. Label colors correspond locations (health facilities):  sorted samples:  symmetric distance measures, one triangles can used display relevant information, p-values, geographic distance, number non-missing loci two samples. , use add = TRUE.  reference, add colorbar legend plot. can placed beside main plot:  colorbar can also located empty space left triangular matrix. example , specify horizontal colorbar provide custom tick mark locations:","code":"par(mar = c(3, 3, 1, 1)) alpha <- 0.05                          # significance level                     dmat <- dres0[, , \"estimate\"] # create symmetric matrix dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))]   # determine significant, reverse columns for upper triangle isig <- which(dres0[, , \"p_value\"] <= alpha, arr.ind = TRUE)[, 2:1]  plotRel(dmat, isig = isig, draw_diag = TRUE, lwd_diag = 0.5, idlab = TRUE,          col_id = c(3:4)[factor(meta$province)]) par(mar = c(1, 3, 3, 1)) nsmp  <- length(dsmp) atsep <- cumsum(nsite)[-length(nsite)] isig  <- which(dres[, , \"p_value\"] <= alpha, arr.ind = TRUE) dmat  <- dres[, , \"estimate\"] dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))]  col_id <- rep(c(\"plum4\", \"lightblue4\"), nsite) plotRel(dmat, isig = rbind(isig, isig[, 2:1]), draw_diag = TRUE, alpha = alpha,         idlab = TRUE, side_id = c(2, 3), col_id = col_id, srt_id = c(25, 65)) abline(v = atsep, h = atsep, col = \"gray45\", lty = 5) par(mfrow = c(1, 2), mar = c(1, 0, 1, 0.2)) plotRel(dres, draw_diag = TRUE, alpha = alpha) mtext(\"p-values\", 3, 0.2) # p-values for upper triangle pmat <- matrix(NA, length(dsmp), length(dsmp)) pmat[upper.tri(pmat)] <- t(log(dres[, , \"p_value\"]))[upper.tri(pmat)] pmat[pmat == -Inf] <- min(pmat[is.finite(pmat)])#*1.2 plotRel(pmat, rlim = NULL, draw_diag = TRUE, col = hcl.colors(101, \"Red-Purple\"),          sig = FALSE, add = TRUE, col_diag = \"white\", border_diag = \"gray45\") abline(v = atsep, h = atsep, col = \"gray45\", lty = 5)  # number of non-missing loci for upper triangle dmiss <- lapply(dsmp, function(lst) sapply(lst, function(v) all(!v))) nmat <- matrix(NA, nsmp, nsmp)  for (jsmp in 2:nsmp) {   for (ismp in 1:(jsmp - 1)) {     nmat[ismp, jsmp] <- sum(!dmiss[[ismp]] & !dmiss[[jsmp]])   } } nrng <- range(nmat, na.rm = TRUE)  #   par(mar = c(1, 0.2, 1, 0)) plotRel(dres, draw_diag = TRUE, alpha = alpha) mtext(\"number of loci\", 3, 0.2) coln <- hcl.colors(diff(nrng)*2.4, \"Purple-Blue\", rev = TRUE)[1:(diff(nrng) + 1)] plotRel(nmat, rlim = NA, col = coln, add = TRUE,          draw_diag = TRUE, col_diag = \"gray45\", border_diag = \"white\") par(pardef) layout(matrix(1:2, 1), width = c(7, 1)) par(mar = c(1, 1, 2, 1))#, mgp = c(0, 0, 0.5)) plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1])) atclin <- cumsum(nsite) - nsite/2 abline(v = atsep, h = atsep, col = \"gray45\", lty = 5) mtext(provinces, side = 3, at = atclin, line = 0.2) mtext(provinces, side = 2, at = atclin, line = 0.2) par(mar = c(1, 0, 2, 3)) plotColorbar() par(pardef) # horizontal colorbar  par(mar = c(1, 1, 1, 3)) border_sig = \"darkviolet\" plotRel(dres, draw_diag = TRUE, border_diag = border_sig, alpha = alpha,          border_sig = border_sig, lwd_sig = 2) legend(32, 20, pch = 0, col = border_sig, pt.lwd = 2, pt.cex = 1.4,         box.col = \"gray\", legend = expression(\"significant at\" ~~ alpha == 0.05)) text(1:nsmp + 0.3, 1:nsmp - 0.5, labels = names(dsmp), col = col_id, adj = 0,      cex = 0.55, xpd = TRUE) par(fig = c(0.25, 1, 0.81, 0.92), mar = c(1, 1, 1, 1), new = TRUE) plotColorbar(at = c(0.2, 0.4, 0.6, 0.8), horiz = TRUE) ncol <- 301 lines(c(0, ncol, ncol, 0, 0), c(0, 0, 1, 1, 0), col = \"gray\") par(pardef)"},{"path":"https://eppicenter.github.io/dcifer/index.html","id":"further-analysis-of-related-samples","dir":"","previous_headings":"","what":"Further analysis of related samples","title":"Genetic Relatedness Between Polyclonal Infections","text":"Examine pairs determined significantly related significance level  closely allowing multiple pairs strains related two infections. Using ibdEstM, also estimate number positively related pairs  strains compare results yielded constrained model assuming  (faster method) without constraint. addition, look estimates  overall relatedness. Create list significant pairs: full control, can use function ibdPair two samples explore outputs: llik = TRUE, output includes log-likelihood (single parameter use equalr = TRUE), provides basis statistical inference:","code":"# First, create a grid of r values to evaluate over revals <- mapply(generateReval, 1:5, nr = c(1e3, 1e2, 32, 16, 12)) sig1 <- sig2 <- vector(\"list\", nrow(isig)) for (i in 1:nrow(isig)) {   sig1[[i]] <- ibdEstM(dsmp[isig[i, ]], coi[isig[i, ]], afreq, Mmax = 5,                         equalr = FALSE, reval = revals) } for (i in 1:nrow(isig)) {   sig2[[i]] <- ibdEstM(dsmp[isig[i, ]], coi[isig[i, ]], afreq, equalr = TRUE) } M1      <- sapply(sig1, function(r) sum(r > 0))   M2      <- sapply(sig2, length)           rtotal1 <- sapply(sig1, sum)     rtotal2 <- sapply(sig2, sum)      cor(M1, M2)                  #> [1] 0.9486851 cor(rtotal1, rtotal2)  #> [1] 0.9998965 samples <- names(dsmp) sig <- as.data.frame(isig, row.names = FALSE) sig[c(\"id1\", \"id2\")]         <- list(samples[isig[, 1]], samples[isig[, 2]]) sig[c(\"M1\", \"M2\")]           <- list(M1, M2) sig[c(\"rtotal1\", \"rtotal2\")] <- list(round(rtotal1, 3), round(rtotal2, 3)) head(sig) #>   row col        id1        id2 M1 M2 rtotal1 rtotal2 #> 1  14   2 8025874706 8025874271  1  1   0.410   0.412 #> 2  52   2 8034209790 8025874271  1  1   0.133   0.133 #> 3  25   3 8034209803 8025874316  1  1   1.000   1.000 #> 4  16   5 8025874872 8025874340  2  2   0.520   0.516 #> 5  17   6 8025874928 8025874357  1  1   1.000   1.000 #> 6  21   6 8025875042 8025874357  1  1   0.881   0.881 i <- 18                               pair <- dsmp[isig[i, ]] coii <-  coi[isig[i, ]]  res1 <- ibdPair(pair, coii, afreq, M = M1[i], pval = TRUE, equalr = FALSE,                   reval = revals[[M1[i]]]) res2 <- ibdPair(pair, coii, afreq, M = M2[i], pval = TRUE, equalr = TRUE,                   confreg = TRUE, llik = TRUE, reval = revals[[1]])  res1$rhat                              # estimate with equalr = FALSE #> [1] 0.31 1.00 rep(res2$rhat, M2[i])                  # estimate with equalr = TRUE #> [1] 0.673 0.673 CI     <- range(res2$confreg) llikCI <- max(res2$llik) - qchisq(1 - alpha, df = 1)/2 llrng  <- range(res2$llik[is.finite(res2$llik)]) yCI <- llrng + diff(llrng)*0.25 yLR <- (res2$llik[1] + max(res2$llik))/2 cols <- c(\"purple\", \"cadetblue3\", \"gray60\")  par(mar = c(3, 2.5, 2, 0.1), mgp = c(1.5, 0.3, 0)) plot(revals[[1]], res2$llik, type = \"l\", xlab = \"r\", ylab = \"log-likelihood\",       yaxt = \"n\")#, tck = -0.01) abline(v = res2$rhat, lty = 1, col = cols[1]) abline(h = c(max(res2$llik), llikCI, res2$llik[[1]]), lty = 2, col = cols[2]) abline(v = CI, col = cols[1], lty = 5) arrows(CI[1], yCI, CI[2], yCI, angle = 20, length = 0.1, code = 3,         col = cols[3]) arrows(0.15, res2$llik[1], 0.15, max(res2$llik), angle = 20, length = 0.1,         code = 3, col = cols[3]) text(0.165, yLR, adj = 0, \"0.5 LR statistic\", col = cols[3]) text(mean(CI), yCI + 0.05*diff(llrng), \"confidence interval\", col = cols[3]) text(res2$rhat - 0.025, yLR, \"MLE\", col = cols[3], srt = 90) par(pardef)"},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Relatedness — ibdDat","title":"Pairwise Relatedness — ibdDat","text":"Provides pairwise relatedness estimates within dataset two datasets along optional p-values confidence intervals (CI).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Relatedness — ibdDat","text":"","code":"ibdDat(   dsmp,   coi,   afreq,   dsmp2 = NULL,   coi2 = NULL,   pval = TRUE,   confint = FALSE,   rnull = 0,   alpha = 0.05,   nr = 1000,   reval = NULL )"},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Relatedness — ibdDat","text":"dsmp list element corresponding one sample. coi vector containing complexity infection sample. afreq list allele frequencies. element list corresponds locus. dsmp2 list representing second dataset. coi2 vector complexities infection second dataset. pval logical value specifying p-values returned. confint logical value specifying confidence intervals returned. rnull null value relatedness parameter hypothesis testing (needed pval = TRUE). alpha significance level 1 - α confidence region. nr integer specifying precision estimate: resolution grid parameter values ([0, 1] divided nr equal intervals), likelihood calculated. Ignored non-null reval provided. reval vector single-row matrix. grid parameter values, likelihood calculated.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Relatedness — ibdDat","text":"matrix pval confint FALSE 3-dimensional arrays otherwise. matrices lower triangular distances calculated within dataset. 3-dimensional array, stacked matrices contain relatedness estimates, p-values, endpoints confidence intervals (requested).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pairwise Relatedness — ibdDat","text":"function, M set 1. confint = FALSE, Newton's method used find estimates, otherwise likelihood calculated grid parameter values.","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/IBDdat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Relatedness — ibdDat","text":"","code":"coi   <- getCOI(dsmp, lrank = 2)           # estimate COI afreq <- calcAfreq(dsmp, coi, tol = 1e-5)  # estimate allele frequencies  # subset of samples for faster processing i1 <- 1:15     # from Maputo i2 <- 31:40    # from Inhambane isub <- c(i1, i2)  # matrix is returned dres1 <- ibdDat(dsmp[isub], coi[isub], afreq, pval = FALSE) dim(dres1) #> [1] 25 25  # test a null hypothesis H0: r = 0, change precision dres2 <- ibdDat(dsmp[isub], coi[isub], afreq, pval = TRUE, rnull = 0,                 nr = 1e2) dim(dres2) #> [1] 25 25  2  # test H0: r = 0.2, include 99% confidence intervals dres3 <- ibdDat(dsmp[isub], coi[isub], afreq, pval = TRUE, confint = TRUE,                 rnull = 0.2, alpha = 0.01) dres3[2, 1, ] #>   estimate    p_value   CI_lower   CI_upper  #> 0.00000000 0.00595283 0.00000000 0.18100000   # pairwise relatedness between two datasets, H0: r = 0 drbetween <- ibdDat(dsmp[i1], coi[i1], afreq,                     dsmp2 = dsmp[i2], coi2 = coi[i2]) dim(drbetween) #> [1] 15 10  2 drbetween[1, 2, ] #>  estimate   p_value  #> 0.0559615 0.1967857  sum(is.na(drbetween[, , 1])) #> [1] 0"},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":null,"dir":"Reference","previous_headings":"","what":"Relatedness Between Two Samples — ibdPair","title":"Relatedness Between Two Samples — ibdPair","text":"Provides estimates relatedness pair samples along optional support curve inference.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relatedness Between Two Samples — ibdPair","text":"","code":"ibdPair(   pair,   coi,   afreq,   M,   rhat = TRUE,   pval = FALSE,   confreg = FALSE,   llik = FALSE,   maxllik = FALSE,   rnull = 0,   alpha = 0.05,   equalr = FALSE,   mnewton = NULL,   freqlog = FALSE,   nr = 1000,   reval = NULL,   tol = NULL,   logr = NULL,   neval = NULL,   inull = NULL,   nloc = NULL )"},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relatedness Between Two Samples — ibdPair","text":"pair list length two containing data pair samples. coi vector containing complexity infection sample. afreq list allele frequencies. element list corresponds locus. M number related pairs strains. rhat, pval, confreg, llik, maxllik logical values specifying relatedness estimate, p-value, confidence region, log-likelihood range \\(r\\) values, maximum log-likelihood returned. rnull null value relatedness parameter hypothesis testing (needed pval = TRUE). alpha significance level 1 - α confidence region. equalr logical value. TRUE, level relatedness assumed M pairs strains (r1 = ... = rM). mnewton logical value. TRUE, Newton's method, adapted bounded parameter space, used find MLE. mnewton specified, set TRUE M = 1, confreg   = FALSE, llik = FALSE. freqlog logical value indicating afreq log scale. nr integer specifying precision estimate: resolution grid parameter values ([0, 1] divided nr equal intervals), likelihood calculated. Ignored non-null reval provided. reval matrix representing grid (r1, ..., rM) combinations, likelihood calculated. column single combination. tol tolerance calculating estimate mnewton = TRUE. Set 1/nr provided. logr list returned logReval logs reval quantities. neval number relatedness values/combinations evaluate . inull index value/column reval closest rnull. nloc number loci.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relatedness Between Two Samples — ibdPair","text":"named list multiple output logical values TRUE - vector rhat = TRUE llik = TRUE. Depending logical values, following quantities included: rhat = TRUE, relatedness estimate (vector length 1 equalr = TRUE length M equalr = FALSE); pval = TRUE, p-value; confreg = TRUE, relatedness parameter values grid reval within 1 - α confidence region; llik = TRUE, log-likelihood values relatedness parameter grid (provided reval determined nr); maxllik = TRUE, maximum log-likelihood.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relatedness Between Two Samples — ibdPair","text":"Handling irregular cases: Allele population frequency 0 present: locus skipped (contribute information). Number unique alleles locus greater COI: COI increased locus .","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/IBDpair.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relatedness Between Two Samples — ibdPair","text":"","code":"coi   <- getCOI(dsmp, lrank = 2) afreq <- calcAfreq(dsmp, coi, tol = 1e-5)  # two samples ipair <- c(21, 17) pair <- dsmp[ipair] coip <-  coi[ipair] M    <- 2  res1 <- ibdPair(pair, coip, afreq, M = M, confreg = TRUE, alpha = 0.05,                 equalr = FALSE, reval = revals[[M]]) res2 <- ibdPair(pair, coip, afreq, M = M, llik = TRUE,                 equalr = TRUE, reval = revals[[1]]) res1$rhat #> [1] 0.31 1.00 rep(res2$rhat, M) #> [1] 0.673 0.673  # plot confidence region creg <- cbind(res1$confreg, res1$confreg[2:1, ]) plot(creg[1, ], creg[2, ], xlim = c(0, 1), ylim = c(0, 1), pch = 15,      cex = 0.6, col = \"cadetblue3\", xlab = expression(hat(r)[1]),      ylab = expression(hat(r)[2])) points(res1$rhat, rev(res1$rhat), pch = 16)   # plot log-likelihood plot(revals[[1]], res2$llik, type = \"l\", xlab = \"r\", ylab = \"log-likelihood\")   ipair <- c(41, 50) pair <- dsmp[ipair] coip <-  coi[ipair]  # rtotal at different values of M with and without equality constraint Mmax <- min(coip) for (M in 1:Mmax) {   print(paste0(\"M = \", M))   print(c(sum(ibdPair(pair, coip, afreq, M = M, pval = FALSE,                       equalr = FALSE, reval = revals[[M]])),           ibdPair(pair, coip, afreq, M = M, pval = FALSE, equalr = TRUE)*M))   cat(\"\\n\") } #> [1] \"M = 1\" #> [1] 0.2794297 0.2794297 #>  #> [1] \"M = 2\" #> [1] 0.320 0.316 #>  #> [1] \"M = 3\" #> [1] 0.330 0.327 #>  #> [1] \"M = 4\" #> [1] 0.360 0.332 #>   # M = 1 # log-likelihood for specific r values ibdPair(pair, coip, afreq, M = 1, rhat = FALSE, pval = FALSE, llik = TRUE,         reval = c(0, 0.15, 0.38, 1)) #> [1] -480.7956 -480.2514 -480.1957      -Inf # grid vs Newton's method system.time(   ibdPair(pair, coip, afreq, M = 1, mnewton = TRUE,  tol = 1e-5)) #>    user  system elapsed  #>   0.003   0.000   0.003  system.time(   ibdPair(pair, coip, afreq, M = 1, mnewton = FALSE, nr  = 1e5)) #>    user  system elapsed  #>   0.176   0.000   0.176"},{"path":"https://eppicenter.github.io/dcifer/reference/calcAfreq.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Allele Frequencies — calcAfreq","title":"Calculate Allele Frequencies — calcAfreq","text":"Calculates population allele frequencies data, adjusting COI.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/calcAfreq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Allele Frequencies — calcAfreq","text":"","code":"calcAfreq(dsmp, coi, tol = 1e-04, qstart = 0.5)"},{"path":"https://eppicenter.github.io/dcifer/reference/calcAfreq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Allele Frequencies — calcAfreq","text":"dsmp list element corresponding one sample. coi vector containing complexity infection sample. tol convergence tolerance frequency estimates. qstart starting value frequencies.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/calcAfreq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Allele Frequencies — calcAfreq","text":"list allele frequencies, element numeric vector containing frequencies single locus.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/calcAfreq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Allele Frequencies — calcAfreq","text":"","code":"coi   <- getCOI(dsmp, lrank = 2)           # estimate COI first afreq <- calcAfreq(dsmp, coi, tol = 1e-5)"},{"path":"https://eppicenter.github.io/dcifer/reference/dres.html","id":null,"dir":"Reference","previous_headings":"","what":"Dcifer results — dres","title":"Dcifer results — dres","text":"Results relatedness estimation.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/dres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dcifer results — dres","text":"","code":"dres"},{"path":"https://eppicenter.github.io/dcifer/reference/dres.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dcifer results — dres","text":"three-dimensional array 52 columns, 52 rows, 4 matrices. Dimension names correspond sample ID's (rows columns) types results c(\"estimate\", \"p_value\", \"CI_lower\", \"CI_upper\") (matrices).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/dsmp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample data — dsmp","title":"Sample data — dsmp","text":"Microhaplotype data two clinics Mozambique. Samples sorted location.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/dsmp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample data — dsmp","text":"","code":"dsmp"},{"path":"https://eppicenter.github.io/dcifer/reference/dsmp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample data — dsmp","text":"list 52 elements (samples), element list 87 elements (loci), integer vectors (alleles).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/format.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and Reformat Data — format","title":"Read and Reformat Data — format","text":"readDat readAfreq read data population allele frequencies csv files reformat processing. formatDat formatAfreq reformat corresponding data frames. Original data assumed long format, one row per allele.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and Reformat Data — format","text":"","code":"readDat(sfile, svar, lvar, avar, ...)  formatDat(dlong, svar, lvar, avar)  readAfreq(afile, lvar, avar, fvar, ...)  formatAfreq(aflong, lvar, avar, fvar)"},{"path":"https://eppicenter.github.io/dcifer/reference/format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and Reformat Data — format","text":"sfile name file containing sample data. svar name variable sample ID. lvar name variable locus/marker. avar name variable allele/haplotype. ... additional arguments read.csv(). dlong data frame containing sample data. afile name file containing population allele frequencies. fvar name variable population allele frequiency. aflong data frame containing population allele frequencies.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and Reformat Data — format","text":"readDat formatDat, list elements corresponding samples. element list list binary vectors, one vector locus. readAfreq formatAfreq, list elements corresponding loci. frequencies locus normalized sum 1. Samples, loci, alleles ordered IDs/names.","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read and Reformat Data — format","text":"","code":"sfile <- system.file(\"extdata\", \"MozParagon.csv\", package = \"dcifer\") dsmp  <- readDat(sfile, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\")  # OR, if the dataset is provided as an R data frame, e.g. dlong <- read.csv(sfile) # reformat only: dsmp <- formatDat(dlong, svar = \"sampleID\", lvar = \"locus\", avar = \"allele\")  afile  <- system.file(\"extdata\", \"MozAfreq.csv\", package = \"dcifer\") afreq2 <- readAfreq(afile, lvar = \"locus\", avar = \"allele\", fvar = \"freq\")  # OR, if allele frequencies are provided as an R data frame, e.g. aflong <- read.csv(afile) # reformat only: afreq2 <- formatAfreq(aflong, lvar = \"locus\", avar = \"allele\", fvar = \"freq\")  dsmp2  <- matchAfreq(dsmp, afreq2)"},{"path":"https://eppicenter.github.io/dcifer/reference/generateReval.html","id":null,"dir":"Reference","previous_headings":"","what":"Grid of Parameter Values — generateReval","title":"Grid of Parameter Values — generateReval","text":"Generates grid parameter values evaluate .","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/generateReval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grid of Parameter Values — generateReval","text":"","code":"generateReval(M, rval = NULL, nr = NULL)"},{"path":"https://eppicenter.github.io/dcifer/reference/generateReval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grid of Parameter Values — generateReval","text":"M integer. rval numeric vector parameter values grid. provided, generated dividing [0,   1] nr equal intervals. nr integer. Ignored rval provided.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/generateReval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grid of Parameter Values — generateReval","text":"matrix M rows nr + 1 length(rval) columns.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/generateReval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grid of Parameter Values — generateReval","text":"","code":"reval <- generateReval(M = 2, nr = 1e2) dim(reval) #> [1]    2 5151"},{"path":"https://eppicenter.github.io/dcifer/reference/getCOI.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate COI — getCOI","title":"Calculate COI — getCOI","text":"Calculates complexity infection list samples, using number detected alleles.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/getCOI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate COI — getCOI","text":"","code":"getCOI(dsmp, lrank = 2)"},{"path":"https://eppicenter.github.io/dcifer/reference/getCOI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate COI — getCOI","text":"dsmp list element corresponding one sample. lrank rank locus determine sample's COI (loci ranked number detected alleles).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/getCOI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate COI — getCOI","text":"vector estimated COI sample.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/getCOI.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate COI — getCOI","text":"","code":"coi <- getCOI(dsmp, lrank = 2)"},{"path":"https://eppicenter.github.io/dcifer/reference/ibdEstM.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Relatedness and a Number of Related Strains — ibdEstM","title":"Estimate Relatedness and a Number of Related Strains — ibdEstM","text":"Estimates number related pairs strains two infections along corresponding relatedness estimates optional inference.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/ibdEstM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Relatedness and a Number of Related Strains — ibdEstM","text":"","code":"ibdEstM(   pair,   coi,   afreq,   Mmax = 6,   pval = FALSE,   confreg = FALSE,   llik = FALSE,   rnull = 0,   alpha = 0.05,   equalr = FALSE,   freqlog = FALSE,   nrs = c(1000, 100, 32, 16, 12, 10),   revals = NULL,   tol0 = 1e-09,   logrs = NULL,   nevals = NULL,   nloc = NULL )"},{"path":"https://eppicenter.github.io/dcifer/reference/ibdEstM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Relatedness and a Number of Related Strains — ibdEstM","text":"pair list length two containing data pair samples. coi vector containing complexity infection sample. afreq list allele frequencies. element list corresponds locus. Mmax maximum number related pairs strains evaluate . greater min(coi), set min(coi). pval, confreg, llik logical values specifying p-value, confidence region, log-likelihood range \\(r\\) values returned. rnull null value relatedness parameter hypothesis testing (needed pval = TRUE). alpha significance level 1 - α confidence region. equalr logical value. TRUE, level relatedness assumed M pairs strains (r1 = ... = rM). freqlog logical value indicating afreq log scale. nrs integer vector 'th element correspons M = indicates precision estimate (resolution grid parameter values). Ignored non-null revals provided. revals list 'th element corresponds M = matrix representing grid parameter values (matrix column represents single (r1, ..., rM) combination). tol0 tolerance value estimate considered zero. logrs list 'th element corresponds M = list returned logReval. nevals vector 'th element corresponds M = provides number relatedness values/combinations evaluate . nloc number loci.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/ibdEstM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Relatedness and a Number of Related Strains — ibdEstM","text":"named list multiple output logical values TRUE - vector rhat = TRUE. output includes: relatedness estimate (numeric vector length corresponding estimated number related pairs); p-value pval = TRUE; parameter values grid revals within confidence region confreg = TRUE; log-likelihood values parameter grid revals llik = TRUE.","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/ibdEstM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Relatedness and a Number of Related Strains — ibdEstM","text":"","code":"coi   <- getCOI(dsmp, lrank = 2)           # estimate COI afreq <- calcAfreq(dsmp, coi, tol = 1e-5)  # estimate allele frequencies  # two samples ipair <- c(21, 17) # for higher COI: c(33, 5): COI = 5-6; c(37, 20): 4-3, c(41, 50): 5-4  Mmax  <- min(coi[ipair]) # choose resolution of the grid for different M nrs   <- c(1e3, 1e2, 32, 16, 12, 10)[1:Mmax] revals <- mapply(generateReval, 1:Mmax, nr = nrs)  (res1 <- ibdEstM(dsmp[ipair], coi[ipair], afreq, Mmax = Mmax, equalr = FALSE,                  reval = revals)) #> [1] 0.31 1.00 (res2 <- ibdEstM(dsmp[ipair], coi[ipair], afreq, Mmax = Mmax, equalr = TRUE)) #> [1] 0.673 0.673 # number of related pairs of strains (M') sum(res1 > 0) #> [1] 2 sum(res2 > 0)  # can be 0's #> [1] 2"},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":null,"dir":"Reference","previous_headings":"","what":"Logarithms of reval — logReval","title":"Logarithms of reval — logReval","text":"Calculates logarithms reval 1 - reval, well associated quantities.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Logarithms of reval — logReval","text":"","code":"logReval(reval, M = NULL, neval = NULL, equalr = FALSE)"},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Logarithms of reval — logReval","text":"reval matrix representing grid (r1, ..., rM) combinations, likelihood calculated. column single combination. M number related pairs strains. neval number relatedness values/combinations evaluate . equalr logical value. TRUE, level relatedness assumed M pairs strains (r1 = ... = rM).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Logarithms of reval — logReval","text":"list length 5 contains log(reval), log(1 -   reval), number reval = 1 column, number 0 < reval < 1 column, sum(log(1 - reval[reval <   1])) column.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Logarithms of reval — logReval","text":"equalr = TRUE relatedness estimation, reval 1 x neval matrix.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/logReval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Logarithms of reval — logReval","text":"","code":"reval <- generateReval(M = 2, nr = 1e2) logr  <- logReval(reval, M = 2, equalr = FALSE)  reval <- generateReval(M = 1, nr = 1e3) logr3  <- logReval(reval, M = 3, equalr = TRUE) logr1  <- logReval(reval, M = 1) all(logr3$sum1r == logr1$sum1r*3) #> [1] TRUE"},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":null,"dir":"Reference","previous_headings":"","what":"Match Samples and Allele Frequencies — matchAfreq","title":"Match Samples and Allele Frequencies — matchAfreq","text":"Checks list containing sample data conformable provided population allele frequencies reformats needed.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match Samples and Allele Frequencies — matchAfreq","text":"","code":"matchAfreq(dsmp, afreq)"},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match Samples and Allele Frequencies — matchAfreq","text":"dsmp list element corresponding one sample. afreq list allele frequencies. element list corresponds locus.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match Samples and Allele Frequencies — matchAfreq","text":"list length dsmp, element matching lengths names afreq elements.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match Samples and Allele Frequencies — matchAfreq","text":"function reorders loci alleles dsmp match afreq inserts alleles dsmp present afreq dsmp; handle cases alleles present dsmp afreq. Allele names required procedure.","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/matchAfreq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match Samples and Allele Frequencies — matchAfreq","text":"","code":"afile  <- system.file(\"extdata\", \"MozAfreq.csv\", package = \"dcifer\") afreq2 <- readAfreq(afile, lvar = \"locus\", avar = \"allele\", fvar = \"freq\") dsmp2  <- matchAfreq(dsmp, afreq2)"},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":null,"dir":"Reference","previous_headings":"","what":"Colorbar — plotColorbar","title":"Colorbar — plotColorbar","text":"Creates colorbar plot.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Colorbar — plotColorbar","text":"","code":"plotColorbar(   rlim = c(0, 1),   by = 0.1,   at = NULL,   horiz = FALSE,   col = grDevices::hcl.colors(301, \"YlGnBu\", rev = TRUE),   ... )"},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Colorbar — plotColorbar","text":"rlim range values represented colors. increment size tickmark locations. Ignored provided. vector tickmark locations. horiz logical value specifying colorbar drawn horizontally. col colors colorbar. ... graphical parameters.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Colorbar — plotColorbar","text":"NULL; called plotting.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Colorbar — plotColorbar","text":"colorbar fill whole plotting region, needs specified outside function control proportions location colorbar (see examples). match colors main plot, rlim values plotRel plotColorbar; rlim = NULL rlim = NA plotRel, provide actual range relatedness estimates plotColorbar (see examples).","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/plotColorbar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Colorbar — plotColorbar","text":"","code":"parstart <- par(no.readonly = TRUE)   # save starting graphical parameters  # colorbar on the side of the main plot layout(matrix(1:2, 1), width = c(7, 1)) par(mar = c(2, 0, 2, 0) + 0.1) # make symmetric matrix dmat <- dres[, , \"estimate\"] dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))] isig <- which(dres[, , \"p_value\"] <= 0.05, arr.ind = TRUE) plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1])) abline(v = 26, h = 26, col = \"gray45\", lty = 5) par(mar = c(2, 1, 2, 2) + 0.1) plotColorbar()   # shorter colorbar, tick mark locations provided par(mar = c(2, 0, 2, 0) + 0.1) plotRel(dmat, draw_diag = TRUE, isig = rbind(isig, isig[, 2:1])) par(mar = c(5, 0.5, 5, 2.5) + 0.1) plotColorbar(at = c(0.0625, 0.125, 0.25, 0.5, 0.78))  par(parstart)  # triangular matrix, inset horizontal colorbar par(mar = c(1, 1, 1, 1)) plotRel(dres, rlim = NULL, draw_diag = TRUE, border_diag = 1, alpha = 0.05) par(fig = c(0.3, 1.0, 0.73, 0.83), new = TRUE) rlim <- range(dres[, , 1], na.rm = TRUE) plotColorbar(rlim = rlim, at = c(0.2, 0.4, 0.6, 0.8), horiz = TRUE)  par(parstart)"},{"path":"https://eppicenter.github.io/dcifer/reference/plotRel.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Relatedness Estimates — plotRel","title":"Plot Relatedness Estimates — plotRel","text":"Represents matrix pairwise relatedness estimates colors corresponding levels relatedness. Optionally, also outlines results hypothesis testing. plot follows matrix layout.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/plotRel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Relatedness Estimates — plotRel","text":"","code":"plotRel(   r,   rlim = c(0, 1),   isig = NULL,   alpha = NULL,   col = grDevices::hcl.colors(101, \"YlGnBu\", rev = TRUE),   draw_diag = FALSE,   col_diag = \"gray\",   border_diag = NA,   lwd_diag = 0.5,   border_sig = \"orangered2\",   lwd_sig = 1.5,   xlab = \"\",   ylab = \"\",   add = FALSE,   idlab = FALSE,   side_id = c(1, 2),   col_id = 1,   cex_id = 0.5,   srt_id = NULL,   ... )"},{"path":"https://eppicenter.github.io/dcifer/reference/plotRel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Relatedness Estimates — plotRel","text":"r matrix 3-dimensional array returned ibdDat. rlim range values colors. NULL NA, calculated r. isig matrix two columns providing indices relatedness matrix entries outlined (\"significant\" sample pairs). Takes precedence alpha. alpha significance level hypothesis testing; determines relatedness matrix entries outlined. Ignored isig NULL. col colors range relatedness values. draw_diag logical value specifying diagonal cells distinguished others separate color. col_diag, border_diag, lwd_diag color fill, color border, line width border diagonal entries. Ignored draw_diag = FALSE. border_sig, lwd_sig color line width outlining entries specified isig alpha. xlab, ylab axis labels. add logical value specifying graphics added existing plot (useful triangular matrices). idlab logical value specifying sample ID's displayed. side_id integer vector specifying plot sides sample ID labels. col_id, cex_id numeric vectors color size sample ID labels. srt_id vector length side_id specifying rotation angles sample ID labels. NULL, labels perpendicular axes. ... graphical parameters.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/plotRel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Relatedness Estimates — plotRel","text":"NULL; called plotting.","code":""},{"path":[]},{"path":"https://eppicenter.github.io/dcifer/reference/plotRel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Relatedness Estimates — plotRel","text":"","code":"parstart <- par(no.readonly = TRUE)   # save starting graphical parameters  par(mar = c(0.5, 0.5, 0.5, 0.5)) plotRel(dres, alpha = 0.05, draw_diag = TRUE)  # draw log of p-values in the upper triangle pmat <- matrix(NA, nrow(dres), ncol(dres)) pmat[upper.tri(pmat)] <- t(log(dres[, , \"p_value\"]))[upper.tri(pmat)] pmat[pmat == -Inf] <- min(pmat[is.finite(pmat)]) plotRel(pmat, rlim = NULL, draw_diag = TRUE, col = hcl.colors(101, \"PuRd\"),         add = TRUE, col_diag = \"slategray2\", border_diag = 1)   # symmetric matrix, outline significant in upper triangle, display sample ID par(mar = c(3, 3, 0.5, 0.5)) dmat <- dres[, , \"estimate\"] dmat[upper.tri(dmat)] <- t(dmat)[upper.tri(t(dmat))] isig <- which(dres[, , \"p_value\"] <= 0.05, arr.ind = TRUE) col_id <- rep(c(\"plum4\", \"lightblue4\"), each = 26) plotRel(dmat, isig = isig[, 2:1], draw_diag = TRUE, idlab = TRUE,         col_id = col_id) abline(v = 26, h = 26, col = \"gray45\", lty = 5)   # rotated sample ID labels on all sides par(mar = c(3, 3, 3, 3)) plotRel(dmat, isig = rbind(isig, isig[, 2:1]), border_sig = \"magenta2\",         draw_diag = TRUE, idlab = TRUE, side_id = 1:4, col_id = col_id,         srt_id = c(-55, 25, 65, -35))  par(parstart)"},{"path":"https://eppicenter.github.io/dcifer/reference/probUxUy.html","id":null,"dir":"Reference","previous_headings":"","what":"Likelihood for\nUx,\nUy — probUxUy","title":"Likelihood for\nUx,\nUy — probUxUy","text":"Calculates log-likelihood pair samples single locus.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/probUxUy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Likelihood for\nUx,\nUy — probUxUy","text":"","code":"probUxUy(   Ux,   Uy,   nx,   ny,   probs,   M,   logj,   factj,   equalr = FALSE,   mnewton = TRUE,   reval = NULL,   logr = NULL,   neval = NULL )"},{"path":"https://eppicenter.github.io/dcifer/reference/probUxUy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Likelihood for\nUx,\nUy — probUxUy","text":"Ux, Uy sets unique alleles two samples given locus. Vectors indices corresponding ordered probabilities probs. nx, ny complexity infection two samples. Vectors length 1. probs vector population allele frequencies (log scale) given locus. checked frequencies regular scale sum 1. M number related pairs strains. logj, factj numeric vectors containing precalculated logarithms factorials. equalr logical value. TRUE, level relatedness assumed M pairs strains (r1 = ... = rM). mnewton logical value. TRUE, coefficients using Newton's method calculated. reval matrix representing grid (r1, ..., rM) combinations, likelihood calculated. column single combination. logr list length 5 returned logReval. neval number relatedness values/combinations evaluate .","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/probUxUy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Likelihood for\nUx,\nUy — probUxUy","text":"mnewton = TRUE, vector length 2 containing coefficients fast likelihood calculation; mnewton = FALSE, vector length neval containing log-likelihoods range parameter values.","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/probUxUy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Likelihood for\nUx,\nUy — probUxUy","text":"","code":"Ux <- c(1, 3, 7)                       # detected alleles at locus t Uy <- c(2, 7) coi <- c(5, 6) aft <- runif(7)                        # allele frequencies for locus t aft <- log(aft/sum(aft))  logj  <- log(1:max(coi)) factj <- lgamma(0:max(coi) + 1)  # M = 2, equalr = FALSE M <- 2 reval <- generateReval(M, nr = 1e2) logr  <- logReval(reval, M = M) llikt <- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,                   equalr = FALSE, logr = logr, neval = ncol(reval)) length(llikt) #> [1] 5151  # M = 2, equalr = TRUE reval <- matrix(seq(0, 1, 0.001), 1) logr  <- logReval(reval, M = M, equalr = TRUE) llikt <- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,                   equalr = TRUE, logr = logr, neval = ncol(reval))  # M = 1, mnewton = FALSE M <- 1 reval <- matrix(seq(0, 1, 0.001), 1) logr  <- logReval(reval, M = M) llikt <- probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj,                   mnewton = FALSE, reval = reval, logr = logr,                   neval = ncol(reval))  # M = 1, mnewton = TRUE probUxUy(Ux, Uy, coi[1], coi[2], aft, M, logj, factj, mnewton = TRUE) #> [1] 7.561708e-13 1.457363e-11"},{"path":"https://eppicenter.github.io/dcifer/reference/revals.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter grid — revals","title":"Parameter grid — revals","text":"Precalculated parameter grids range values M (1 5).","code":""},{"path":"https://eppicenter.github.io/dcifer/reference/revals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter grid — revals","text":"","code":"revals"},{"path":"https://eppicenter.github.io/dcifer/reference/revals.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Parameter grid — revals","text":"list length 5, element corresponds single value M matrix M rows. column matrix r1 = ... = rM) combination.","code":""},{"path":"https://eppicenter.github.io/dcifer/news/index.html","id":"dcifer-120","dir":"Changelog","previous_headings":"","what":"dcifer 1.2.0","title":"dcifer 1.2.0","text":"CRAN release: 2022-10-31 Functions formatDat() formatAfreq() reformat data frames containing sample data population allele frequencies long formats added.","code":""},{"path":"https://eppicenter.github.io/dcifer/news/index.html","id":"dcifer-111","dir":"Changelog","previous_headings":"","what":"dcifer 1.1.1","title":"dcifer 1.1.1","text":"CRAN release: 2022-08-10 Fix: logReval() now covers relevant edge cases.","code":""},{"path":"https://eppicenter.github.io/dcifer/news/index.html","id":"dcifer-110","dir":"Changelog","previous_headings":"","what":"dcifer 1.1.0","title":"dcifer 1.1.0","text":"CRAN release: 2022-08-06 Special case added: loci shared alleles (efficient); logReval() now argument equalr performs additional checks. Can provide equalr = TRUE M > 1; result reflected sum1r element output.","code":""},{"path":"https://eppicenter.github.io/dcifer/news/index.html","id":"dcifer-101","dir":"Changelog","previous_headings":"","what":"dcifer 1.0.1","title":"dcifer 1.0.1","text":"CRAN release: 2022-07-15 First public release.","code":""}]
